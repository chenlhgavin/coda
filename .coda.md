# CODA Repository Overview

> Auto-generated by CODA. Keep in sync with the codebase.

## Project Overview

CODA (Claude Orchestrated Development Agent) is a Rust-based autonomous development tool that orchestrates Claude AI through a structured pipeline — analyze, plan, implement, review, and PR — to drive feature development end-to-end. It provides two frontends: a Ratatui-based TUI for interactive CLI use and a Slack-integrated server for team workflows. Each feature is developed in an isolated git worktree under `.trees/`, with session state persisted to YAML for resumability. The system uses MiniJinja prompt templates to guide AI through each phase, and supports configurable review engines (Claude or Codex) for automated code review.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    coda-cli (app)                        │
│  Ratatui TUI · Clap CLI · Line Editor · App Driver      │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                   coda-server (app)                      │
│  Slack Integration · Command Dispatch · Session Mgmt    │
│  Repo Clone/Update · Branch Switching · RepoLocks       │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                   coda-core (lib)                        │
│  Engine · Planner · Runner · Reviewer                   │
│  FeatureScanner · GitOps · GhOps (traits)               │
│  Project / Task / State Mgmt · Config · Profiles        │
└──────────┬────────────────────────┬─────────────────────┘
           │                        │
┌──────────▼───────────┐  ┌────────▼─────────────────────┐
│    coda-pm (lib)     │  │  claude-agent-sdk-rs          │
│  Prompt Manager      │  │  (vendored)                   │
│  MiniJinja templates │  │  Claude AI client, streaming  │
│  init / plan / run   │  │  hooks, MCP, plugin types     │
└──────────────────────┘  └──────────────────────────────┘
```

### Core Abstractions

- **`GitOps` trait** (`coda-core::git`): Abstracts all git CLI operations (worktree, branch, commit, diff, push). Default implementation shells out to `git`. Enables unit testing without a real repo.
- **`GhOps` trait** (`coda-core::gh`): Abstracts `gh` CLI operations (PR status, PR listing). Default implementation shells out to `gh`.
- **`FeatureScanner`** (`coda-core::scanner`): Reads `.trees/` to discover features and their `state.yml` files. Separated from Engine for single-responsibility.
- **`Engine`** holds `Arc<dyn GitOps>`, `Arc<dyn GhOps>`, and `FeatureScanner`, sharing them with sub-sessions (`PlanSession`, `Runner`).
- **`RepoLocks`** (`coda-server::state`): `DashMap`-based lock manager that prevents concurrent git operations on the same repository path. Used by branch switching and clone/update operations.
- **`BindingStore`** (`coda-server::state`): Persists channel-to-repository path mappings in `~/.coda-server/config.yml`. Validates paths exist before binding.

## Directory Guide

| Path | Purpose |
|------|---------|
| `apps/coda-cli` | Main CLI binary — TUI, CLI parsing, line editor, app orchestration |
| `apps/coda-server` | Server binary — Slack integration, command dispatch, session management, repo clone/update |
| `apps/coda-server/src/commands/` | Slash command handlers: `init`, `plan`, `run`, `repos`, `query`, `streaming` |
| `apps/coda-server/src/handlers/` | Slack event, interaction, and command dispatch handlers |
| `crates/coda-core` | Core library — engine, planner, runner, reviewer, scanner, git/gh traits, project/task/state management, config, profiles |
| `crates/coda-pm` | Prompt manager — loads and renders MiniJinja prompt templates |
| `crates/coda-pm/templates` | MiniJinja templates organized by workflow phase (`init/`, `plan/`, `run/`, `review/`) |
| `vendors/claude-agent-sdk-rs` | Vendored Rust SDK for Claude Agent (client, streaming, hooks, MCP) |
| `specs/` | Feature specs and design documents (PRDs, design, impl-plans, reviews) |
| `docs/` | Project documentation, research notes, and setup guides |
| `deploy/` | Deployment configuration (systemd service file) |
| `.coda/` | CODA project configuration (`config.yml`) and custom prompts |
| `.trees/` | Git worktrees for parallel feature development (gitignored) |

## Tech Stack

**Languages**
- Rust 2024 edition (primary, pinned via `rust-toolchain.toml`)
- Jinja2 (prompt templates via MiniJinja)

**Frameworks & Runtimes**
- Tokio — async runtime (`rt-multi-thread`)
- Ratatui + Crossterm — TUI rendering
- Clap — CLI argument parsing
- MiniJinja — prompt template engine

**Key Dependencies**
- `claude-agent-sdk-rs` (vendored) — Claude AI client with streaming
- `thiserror` — library error types
- `anyhow` — application error handling
- `serde` / `serde_json` / `serde_yaml` — serialization
- `tracing` / `tracing-subscriber` — structured logging
- `unicode-width` — terminal text width calculation
- `dashmap` — concurrent hash maps (RepoLocks, BindingStore)
- `reqwest` / `tokio-tungstenite` — HTTP and WebSocket for Slack integration
- `chrono` — timestamp formatting in Slack messages

**Build & Tooling**
- Cargo workspace (resolver v2)
- Make — automation targets
- `cargo-nextest` — test runner
- `cargo-release` — release automation
- `git-cliff` — changelog generation
- `cargo-deny` — license/dependency policy
- `typos` — spell checking

## Development Workflow

```bash
# Build
cargo build

# Format (nightly required)
cargo +nightly fmt

# Lint (strict)
cargo clippy -- -D warnings

# Test
cargo test
# or with nextest
cargo nextest run

# Check licenses & banned crates
cargo deny check

# Spell check
typos

# Security audit
cargo audit

# Run the CLI
cargo run -p coda-cli -- <args>

# Run the server
cargo run -p coda-server -- <args>
```

Makefile targets wrap these commands — run `make help` to list available targets.

## Key Patterns

- **Pipeline phases**: Features progress through analyze, plan, implement, review, PR. Each phase has dedicated prompt templates in `crates/coda-pm/templates/`.
- **Git worktrees**: Each feature gets its own worktree under `.trees/` for parallel, isolated development.
- **Stable clone paths**: The Slack server clones repositories to `<workspace>/<owner>/<repo>`, reusing existing clones across selections. Existing clones are auto-updated (fetch + checkout default branch + pull) before binding.
- **Clone-or-reuse**: When a user selects a repository via `/coda repos`, the server checks for an existing `.git` directory. If present, it updates in place; otherwise it performs a fresh clone. Repo name validation prevents path traversal.
- **Repo locking**: `RepoLocks` prevents concurrent git operations on the same repository path during clone/update and branch switching.
- **Actor model**: Subsystems own their state and communicate via Tokio channels. No `Mutex`/`RwLock` on shared state — use `DashMap` or `ArcSwap` instead.
- **Error handling**: `thiserror` for library crates, `anyhow` with `.context()` for application binaries. No `unwrap()`/`expect()` in production code.
- **Async traits**: Native `async fn in trait` by default; `async-trait` only when `dyn Trait` object safety is required (documented at module level).
- **Configuration**: YAML files via the `config` crate; runtime-tunable values in config files, compile-time constants in code.
- **State persistence**: Feature state is serialized to `state.yml` in each worktree, enabling resumable sessions.
- **Specs convention**: `specs/{feature-name}-{type}.md` — types include `prd`, `design`, `impl-plan`, `verification-plan`, `review`. Update `specs/index.md` for each new spec.
- **No `unsafe`**: Zero `unsafe` blocks; pure-Rust crates preferred over FFI bindings.
- **Serde conventions**: `#[serde(rename_all = "camelCase")]` for JSON; `skip_serializing_if = "Option::is_none"` to omit nulls.
