# CODA Repository Overview

> Auto-generated by CODA. Keep in sync with the codebase.

## Project Overview

CODA (Claude Orchestrated Development Agent) is an AI-driven development agent that automates the feature development lifecycle from planning through pull request creation. It provides both a CLI with a TUI interface for interactive planning and a Slack server for team-based workflows. The core value proposition is structured, traceable, and resumable AI-assisted development: users describe a feature, an AI agent plans and implements it across phased stages, self-reviews the code, runs verification checks, and opens a pull request -- all with crash recovery and cost tracking.

## Architecture Overview

```
+-------------------------------+      +-------------------------------+
|         apps/coda-cli         |      |       apps/coda-server        |
|   (TUI: Ratatui + Crossterm)  |      |  (Slack Socket Mode server)   |
|   Clap CLI argument parsing   |      |  WebSocket + REST dispatch    |
+---------------+---------------+      +---------------+---------------+
                |                                      |
                |          tokio::sync::mpsc            |
                |        (RunEvent, InitEvent,          |
                |         PlanStreamUpdate)             |
                v                                      v
+------------------------------------------------------------------+
|                        crates/coda-core                          |
|  Engine | PlanSession | Runner | FeatureState | GitOps | GhOps  |
|  Scanner | Config | Task types | AgentProfile | Parsers         |
+----------------------------+---------+---------------------------+
                             |         |
                             v         v
              +----------------+   +-------------------+
              | crates/coda-pm |   | claude-agent-sdk  |
              |  (MiniJinja    |   | -rs (vendored)    |
              |   templates)   |   | subprocess SDK    |
              +----------------+   +-------------------+
```

**coda-core** is the domain layer. It owns the execution engine, planning session, phased runner, state machine, and external tool abstractions (GitOps/GhOps traits). Both application binaries are thin frontends that delegate all domain logic here.

**coda-pm** is a utility layer providing Jinja2-style prompt template loading and rendering via MiniJinja. Templates are organized by workflow stage (`init/`, `plan/`, `run/`, `commit/`).

**coda-cli** provides an interactive TUI (Ratatui + Crossterm) for planning sessions and run progress display. It consumes streaming events from coda-core via unbounded mpsc channels.

**coda-server** provides a Slack interface via Socket Mode WebSocket. It routes slash commands through a dispatch layer to command handlers that delegate to coda-core. Uses DashMap for concurrent session and binding state.

## Interface Design

### GitOps (`crates/coda-core/src/git.rs`)
Abstracts all git CLI operations: worktree add/remove, commit, branch, diff, push. `DefaultGitOps` shells out to `git`. Trait-based for testability without a real repository.

### GhOps (`crates/coda-core/src/gh.rs`)
Abstracts GitHub CLI operations: PR view, PR list, PR URL lookup. `DefaultGhOps` shells out to `gh`. Trait-based for testability without gh auth.

### Engine (`crates/coda-core/src/engine.rs`)
Top-level orchestrator composing GitOps, GhOps, FeatureScanner, PlanSession, and Runner. Entry points: `init()`, `plan()`, `run()`, `clean()`.

### PlanSession (`crates/coda-core/src/planner.rs`)
Multi-turn interactive planning conversation wrapping `ClaudeClient`. Manages connect/disconnect, streaming, approve, and finalize (writes specs + state + worktree). Uses the Planner profile (read-only tools).

### Runner (`crates/coda-core/src/runner.rs`)
Executes feature development through phased stages. Manages a single `ClaudeClient` session with state persistence for crash recovery. Emits `RunEvent` progress events via mpsc channel.

### AgentProfile (`crates/coda-core/src/profile.rs`)
Maps task types to `ClaudeAgentOptions`. Two profiles: Planner (read-only tools) and Coder (full tools + safety hooks).

### PromptManager (`crates/coda-pm/src/manager.rs`)
Template registry that loads `.j2` files from directories and built-in sources. Renders with MiniJinja contexts. Supports user overrides via `extra_dirs`.

### FeatureState (`crates/coda-core/src/state.rs`)
Persistent state machine for feature execution. Serialized to `state.yml`. Supports validation, migration, and resume from last completed phase.

## Data Flow

### Feature Development Pipeline (`coda run`)

```
state.yml ──> Load & Resume ──> [Dev Phase 1] ──> ... ──> [Dev Phase N]
                                     |                         |
                                  commit +                  commit +
                                  update state              update state
                                                               |
                                                               v
              [Review] ──> [Verify] ──> [Update Docs] ──> [Create PR]
                  |            |              |                 |
              self-review   cargo build   update .coda.md   squash,
              + codex       fmt, clippy   + README.md       push,
              review        test                            gh pr create
```

1. **Load state** -- Read `FeatureState` from `.coda/<feature>/state.yml`, resume from `current_phase`
2. **Dev phases** -- For each phase: render prompt template, send to Claude (Coder profile), stream response with idle timeout + reconnection, commit changes, update state, emit `RunEvent`
3. **Review** -- Claude self-review and/or Codex independent review (engine: claude/codex/hybrid), iterate up to `max_review_rounds`
4. **Verify** -- Run configured checks (`cargo build`, `fmt`, `clippy`, `nextest`), agent fixes failures, retry up to `max_retries`
5. **Update docs** -- Agent updates `.coda.md` and `README.md`
6. **Create PR** -- Squash commits (optional), push branch, create PR via `gh` CLI

### Interactive Planning (`coda plan`)

```
User ──> PlanSession (Planner profile) ──> ClaudeClient ──> streaming response
  ^                                                              |
  |              PlanStreamUpdate events via mpsc                 |
  +──────────────────────────────────────────────────────────────+
                             |
                       User approves
                             |
                             v
              Generate spec + verification plan
              Create worktree, write state.yml
              Initial commit on feature branch
```

### Slack Dispatch (`coda-server`)

```
Slack ──> WebSocket envelope ──> dispatch()
              |
              +── slash_commands ──> command handler ──> Engine
              +── events_api ──> event handler
              +── interactive ──> interaction handler
              |
              v
         BindingStore (DashMap) resolves channel -> repo
         Progress streamed to Slack thread via SlackClient
```

## Core Data Structures

### FeatureState (`state.rs`)
Persistent state tracking feature execution. Fields: `feature` (FeatureInfo), `status` (FeatureStatus enum), `current_phase` (u32), `git` (GitInfo), `phases` (Vec<PhaseRecord>), `pr` (Option<PrInfo>), `total` (TotalStats). Serialized as YAML.

### FeatureStatus
Enum: `Planned`, `Running`, `Completed`, `Failed`. Tracks overall lifecycle.

### Task (`task.rs`)
Enum representing pipeline work units: `Init`, `Plan`, `DevPhase`, `Review`, `Verify`, `UpdateDocs`, `CreatePr`. Each variant carries relevant context (feature_slug, phase name).

### TaskResult (`task.rs`)
Execution outcome with metrics: `task`, `status` (TaskStatus), `turns`, `cost_usd`, `duration`, `artifacts`.

### PhaseRecord (`state.rs`)
Per-phase execution record: name, kind (Dev/Quality), status, cost, token counts, duration.

### CodaConfig (`config.rs`)
Project configuration loaded from `.coda/config.yml`. Covers agent settings, git conventions, and review checks.

## Module Guide

| Path | Purpose |
|------|---------|
| `crates/coda-core/` | Domain layer: Engine, PlanSession, Runner, GitOps/GhOps traits, state, config, task types, parsers, profiles |
| `crates/coda-pm/` | Prompt Manager: template loading, rendering, built-in `.j2` templates |
| `crates/coda-pm/templates/` | Jinja2 prompt templates by stage: `init/`, `plan/`, `run/`, `commit/` |
| `apps/coda-cli/` | CLI application: TUI (Ratatui), interactive planning, run progress display |
| `apps/coda-server/` | Slack server: Socket Mode WebSocket, slash command dispatch, session management |
| `vendors/claude-agent-sdk-rs/` | Vendored Claude Agent SDK (git submodule) |
| `deploy/` | Deployment config: systemd service unit for coda-server |
| `.coda/` | Project-level CODA config and feature state directories |
| `.trees/` | Git worktrees for feature branches |

## Tech Stack & Dependencies

| Category | Technology | Role |
|----------|-----------|------|
| Language | Rust (Edition 2024) | Primary language |
| Async runtime | Tokio 1.43 | Multi-threaded async runtime |
| TUI | Ratatui 0.30 + Crossterm 0.29 | Terminal UI for CLI |
| CLI parsing | Clap 4.5 | Argument parsing with derive macros |
| Templates | MiniJinja 2.6 | Jinja2-style prompt rendering |
| WebSocket | Tokio-Tungstenite 0.24 | Slack Socket Mode connection |
| HTTP | Reqwest 0.12 (rustls-tls) | Slack Web API client |
| Serialization | Serde + serde_yaml + serde_json | YAML/JSON (de)serialization |
| Error handling | thiserror 2.0 / anyhow 1.0 | Library error enums / app error propagation |
| Logging | tracing 0.1 + tracing-subscriber 0.3 | Structured logging with env-filter |
| Concurrency | DashMap 6.1 | Lock-free concurrent HashMap |
| AI SDK | claude-agent-sdk-rs 0.6 | Claude subprocess communication |
| Testing | cargo-nextest | Parallel test runner |
| Linting | cargo-deny, typos | Dependency policy, spell checking |
| Changelog | git-cliff | Conventional commit changelog generation |

## Development Workflow

```bash
# Build
cargo build                              # Debug build
cargo build --release --bin coda-server   # Release build (server)

# Test
cargo nextest run --all-features         # Run all tests
cargo test -- --ignored                  # Run slow/ignored tests

# Format & Lint
cargo +nightly fmt                       # Format code
cargo +nightly fmt -- --check            # Check formatting
cargo clippy -- -D warnings              # Lint with warnings as errors

# Other
cargo audit                              # Security vulnerability check
cargo doc --open                         # Generate and view docs
make deploy                              # Build release + install systemd + restart
```

## Key Patterns & Conventions

**Actor-like concurrency**: Subsystems (PlanSession, Runner) own their state and communicate via `tokio::sync::mpsc` channels. Streaming events (`RunEvent`, `PlanStreamUpdate`, `InitEvent`) flow from core to UI/server layers.

**Trait-based abstraction**: External tool interactions (git, gh) are behind traits (`GitOps`, `GhOps`) with default implementations that shell out to CLI tools. This enables unit testing without real repositories.

**State machine persistence**: `FeatureState` is serialized to YAML after each phase, enabling crash recovery by resuming from `current_phase`. State includes cost tracking and PR metadata.

**Error handling**: Library crates use `thiserror` enums (`CoreError`, `PromptError`) with `#[non_exhaustive]`. Apps use `anyhow::Result` with `.context()`. No `unwrap()`/`expect()` in production code.

**Profile-based agent config**: `AgentProfile` maps task types to Claude SDK options. Planner profile restricts to read-only tools; Coder profile enables full tools with safety hooks.

**Template-driven prompts**: All agent prompts are MiniJinja `.j2` templates organized by workflow stage. User overrides via `extra_dirs` allow customization without modifying built-in templates.

**Configuration**: YAML-based via `.coda/config.yml`. Runtime-tunable values in config; compile-time constants for fixed values.

**Graceful shutdown**: `tokio::sync::watch` channel for shutdown signaling. Server disconnects all active sessions on SIGTERM/SIGINT.
