# CODA Repository Overview

> Auto-generated by CODA. Keep in sync with the codebase.

## Project Overview

CODA (Claude Orchestrated Development Agent) is an AI-driven development lifecycle orchestrator that automates the full feature development pipeline — from planning through implementation, review, verification, documentation, and pull request creation. It integrates multiple AI backends (Claude, Codex, Cursor) via a unified SDK and exposes two interfaces: a TUI-based CLI for interactive local development and a Slack Socket Mode server for team-based workflows. The core value proposition is structured, traceable, crash-recoverable feature development with AI assistance at every stage.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    Application Layer                     │
│  ┌──────────────────┐       ┌─────────────────────────┐ │
│  │    coda-cli       │       │     coda-server          │ │
│  │  (TUI + clap)     │       │  (Slack Socket Mode)     │ │
│  └────────┬─────────┘       └───────────┬─────────────┘ │
├───────────┼─────────────────────────────┼───────────────┤
│           │         Core Layer          │               │
│           └──────────┬──────────────────┘               │
│              ┌───────▼────────┐                         │
│              │   coda-core     │                         │
│              │ Engine, Runner, │                         │
│              │ PlanSession,    │                         │
│              │ Phases, State   │                         │
│              └──┬──────────┬──┘                         │
├─────────────────┼──────────┼────────────────────────────┤
│                 │ SDK/Lib  │                             │
│       ┌─────────▼──┐  ┌───▼──────────┐                 │
│       │coda-agent-  │  │  coda-pm      │                 │
│       │sdk          │  │ (Prompt Mgr)  │                 │
│       │Backend,     │  │ Jinja2/.j2    │                 │
│       │Session,     │  │ templates     │                 │
│       │Transport    │  └───────────────┘                 │
│       └─────────────┘                                   │
├─────────────────────────────────────────────────────────┤
│  External: git CLI, gh CLI, Claude CLI, Codex CLI,      │
│            Cursor CLI, Slack API                         │
└─────────────────────────────────────────────────────────┘
```

- **coda-cli** — Thin TUI binary. Parses CLI args (clap), renders interactive planning sessions and phased execution progress via ratatui + crossterm with markdown rendering.
- **coda-server** — Thin Slack server binary. Receives Socket Mode envelopes, dispatches to command handlers, streams progress as Slack thread replies.
- **coda-core** — Orchestration engine. `Engine` is the top-level facade; `Runner` iterates `PhaseExecutor` implementations (dev, review, verify, docs, PR). `StateManager` persists YAML state for crash recovery. Git/GH operations abstracted behind traits.
- **coda-agent-sdk** — Multi-backend SDK. `Backend` trait creates `Session` objects for interactive multi-turn conversations. `Transport` trait handles low-level I/O. Implementations for Claude, Codex, and Cursor CLIs.
- **coda-pm** — Prompt template manager. Loads `.j2` Jinja2 templates via minijinja and renders them with structured context for all agent prompts.

## Interface Design

| Interface | Module | Abstracts | Purpose |
|-----------|--------|-----------|---------|
| `Backend` | `coda-agent-sdk/src/backend/mod.rs` | AI CLI backends | Runtime backend selection via `Box<dyn Backend>`. Defines capabilities, one-shot queries, session creation. |
| `Session` | `coda-agent-sdk/src/backend/mod.rs` | Multi-turn conversation | Interactive session lifecycle: send/receive messages, control requests. `Box<dyn Session + Send>`. |
| `Transport` | `coda-agent-sdk/src/transport/mod.rs` | Subprocess I/O | Low-level connect/write/read/close for Claude subprocess communication. Enables custom transports. |
| `GitOps` | `coda-core/src/git.rs` | git CLI operations | Worktree, commit, push, diff, branch. `Arc<dyn GitOps>` for testability. Must be `Send + Sync`. |
| `GhOps` | `coda-core/src/gh.rs` | GitHub CLI operations | PR view/list/URL discovery. Trait-based for testability without real GitHub. |
| `PhaseExecutor` | `coda-core/src/phases/mod.rs` | Phase execution logic | Each phase (dev, review, verify, docs) implements `execute(PhaseContext) -> TaskResult`. Dispatched via match. |
| `AgentSession` | `coda-core/src/session.rs` | Session wrapper | Idle timeout detection, exponential backoff reconnection, response accumulation, cancellation. |
| `StateManager` | `coda-core/src/state.rs` | State persistence | Phase-transition invariant enforcement, YAML persistence, derives `current_phase` from statuses. |
| `PromptManager` | `coda-pm/src/manager.rs` | Template rendering | Loads `.j2` templates by name, renders with structured context via minijinja. |

## Data Flow

### Feature Development Pipeline (CLI)

```
coda init ──► coda plan ──► coda run ──────────────────────────────► done
                │                │
                ▼                ▼
          PlanSession       Runner loads FeatureState
          (multi-turn)      iterates PhaseExecutors:
          produces specs        │
          in .coda/<slug>/      ├─► Dev: templated prompts → agent writes code
                                ├─► Review: multi-round self-review (+ Codex)
                                ├─► Verify: build/fmt/lint/test with retries
                                ├─► Docs: update documentation
                                └─► PR: build body from specs, gh pr create, push
```

1. **Init** — Engine analyzes repo via Claude, generates `.coda/config.yml`
2. **Plan** — PlanSession runs multi-turn TUI conversation, produces design spec + verification plan in `.coda/<slug>/specs/`
3. **Run** — Runner loads `FeatureState`, creates `AgentSession`, iterates `PhaseExecutor` chain
4. **Dev** — `DevPhaseExecutor` sends templated prompts, agent writes code in isolated worktree
5. **Review** — `ReviewPhaseExecutor` runs multi-round Claude self-review (optional Codex cross-review)
6. **Verify** — `VerifyPhaseExecutor` runs build/fmt/lint/test checks with bounded retries
7. **Docs** — `DocsPhaseExecutor` updates documentation based on changes
8. **PR** — Builds PR body from specs/summaries, agent runs `gh pr create`, git push, state → Completed

### Agent SDK Message Flow

```
AgentSdkClient ──connect()──► Backend::create_session() ──► Session (subprocess)
     │                                                           │
     ├── send_message(Prompt) ──────────────────────────────────►│
     │                                                           │
     │◄── receive_response() ── Message stream ──────────────────┤
     │    (User | Assistant | System | StreamEvent | Result)      │
     │                                                           │
AgentSession wraps with: idle timeout → reconnect w/ backoff → resume
```

### Slack Server Request Handling

```
Slack WebSocket ──► parse_message() ──► classify envelope type
     │                                       │
     ├─ Hello/Disconnect: handle internally  │
     └─ Envelope: acknowledge within 3s      │
                                             ▼
                                  dispatch() matches type:
                                  ├─► SlashCommands → handlers::commands
                                  ├─► EventsApi    → handlers::events
                                  └─► Interactive  → handlers::interactions
                                             │
                                             ▼
                                  Execute via Engine/Runner/PlanSession
                                  Stream progress as Slack thread replies
```

## Core Data Structures

- **`FeatureState`** — Central domain model persisted as YAML. Contains feature metadata, slug, branch, phase statuses, spec paths, and run history. State machine transitions enforced by `StateManager`.
- **`FeatureStatus`** — Enum: `Planned`, `InProgress`, `Completed`, `Failed`, `Cancelled`. Tracks per-phase status.
- **`PhaseContext`** — Passed to each `PhaseExecutor`. Contains agent session, git ops, state manager, config, cancellation token, and event sender.
- **`TaskResult`** — Phase execution outcome. Contains success/failure, summary text, and timing metadata.
- **`Message`** — SDK message types: `User`, `Assistant`, `System`, `StreamEvent`, `Result`. `ResultMessage` carries cost/usage/session_id.
- **`RunEvent`** / **`SessionEvent`** — Event types for progress propagation via channels from Runner/Session to UI/Slack layers.
- **`CodaConfig`** — Project configuration loaded from `.coda/config.yml`. Agent settings, git policies, review checks.

## Module Guide

| Directory | Purpose |
|-----------|---------|
| `crates/coda-core/` | Core orchestration: Engine, Runner, PlanSession, phases, state, git/gh abstractions |
| `crates/coda-core/src/phases/` | Phase executors: dev, review, verify, docs, PR creation |
| `crates/coda-agent-sdk/` | Multi-backend SDK: AgentSdkClient, Backend/Session/Transport traits |
| `crates/coda-agent-sdk/src/backend/` | Backend implementations: Claude, Codex, Cursor adapters |
| `crates/coda-pm/` | Prompt template manager: loads and renders .j2 Jinja2 templates |
| `crates/coda-pm/templates/` | Jinja2 prompt templates by workflow phase (init, plan, run, commit) |
| `apps/coda-cli/` | TUI CLI application: interactive planning, phased execution display |
| `apps/coda-server/` | Slack Socket Mode server: slash commands, event dispatch, sessions |
| `apps/coda-server/src/commands/` | Server command implementations: init, plan, run, query, config |
| `apps/coda-server/src/handlers/` | Slack event handlers: slash commands, Events API, interactive components |
| `deploy/` | Deployment artifacts: systemd service unit, sudoers config |

## Tech Stack & Dependencies

| Category | Details |
|----------|---------|
| Language | Rust (Edition 2024) |
| Async runtime | tokio (rt-multi-thread) |
| TUI | ratatui + crossterm |
| CLI parsing | clap |
| Templating | minijinja (.j2 templates) |
| Serialization | serde + serde_yaml_ng + serde_json |
| Error handling | thiserror (libraries), anyhow (applications) |
| Logging | tracing + tracing-subscriber |
| Concurrency | tokio-util (CancellationToken), futures (Stream), async-trait |
| Testing | cargo-nextest, rstest, proptest, mockall |
| Build/CI | Cargo workspace (5 members), Make, cargo-deny, git-cliff |

## Development Workflow

```bash
cargo build                              # Build all crates
cargo nextest run --all-features         # Run tests (parallel)
cargo +nightly fmt -- --check            # Check formatting
cargo clippy -- -D warnings              # Lint
make build                               # Build via Makefile
make test                                # Test via Makefile
make build-release                       # Release build (coda-server)
make deploy                              # Build + install + restart service
```

## Key Patterns & Conventions

- **Composition over inheritance** — Trait objects (`Arc<dyn GitOps>`, `Box<dyn Backend>`) for runtime polymorphism. No type hierarchies.
- **Message passing** — `tokio::sync::mpsc::unbounded_channel` for event propagation (RunEvent, SessionEvent). No shared mutable state.
- **Cooperative cancellation** — `CancellationToken` threaded through Runner → PhaseContext → AgentSession. Checked at natural phase boundaries.
- **Crash recovery** — `StateManager` persists YAML state on every exit path. `current_phase` derived from statuses, not stored separately.
- **Blocking I/O isolation** — Git/GH CLI calls wrapped in `spawn_blocking` via AsyncGitOps/AsyncGhOps.
- **Error handling** — Library crates: `thiserror` enums with `#[non_exhaustive]`. Apps: `anyhow::Result` with `.context()`. Cancellation is a first-class error variant.
- **Template-driven prompts** — All agent prompts constructed from `.j2` Jinja2 templates via PromptManager, enabling customization without code changes.
- **Configuration** — YAML-based project config (`.coda/config.yml`). Per-operation agent backend overrides. Runtime-tunable values in config, compile-time constants in code.
