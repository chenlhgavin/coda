You are implementing a new feature in an existing codebase. This is **development phase {{ phase_number }}/{{ total_dev_phases }}: {{ phase_name }}**.

## Design Specification

{% if is_first %}
{{ design_spec }}
{% else %}
Refer to the full design specification provided in the first development phase above. The spec file is at `.coda/{{ feature_slug }}/specs/design.md` if you need to re-read any section.
{% endif %}

{% if resume_context %}
## Resume Context

{{ resume_context }}
{% endif %}

## Current Phase

You are working on **Phase {{ phase_number }}: {{ phase_name }}** of the development plan. Locate the corresponding phase in the "Development Phases" section of the design spec above and implement it completely.
{% if phase_goal %}

**Phase Goal**: {{ phase_goal }}
{% endif %}
{% if phase_files %}
**Expected File Changes**: {{ phase_files | join(", ") }}
{% endif %}

{% if is_first %}
## First Phase — Setup & Scaffolding

Since this is the **first** development phase, you may also need to:

1. **Create new directories** listed in the "Directory Structure" section
2. **Create scaffold files** with module declarations, struct/enum definitions, and `use` imports
3. **Update existing files** to register new modules (e.g., `mod` statements, `Cargo.toml` dependencies)

The `.coda/{{ feature_slug }}/` directory contains the design spec, verification plan, and execution state for this feature. It must be tracked in git.
{% endif %}

## Task

Implement all code changes described in this phase using **Test-Driven Development (TDD)**.
Tests MUST be written BEFORE the production code they verify.

### Assess Scope

Before starting, read the phase requirements and assess the code volume:
- **Large scope** (multiple sub-components, new modules, or significant logic): Use the per-component TDD cycle below
- **Small scope** (single component, minor additions): Write all tests upfront, then implement

### TDD Workflow — Per-Component Cycle (Large Scope)

For each sub-component or logical unit in this phase:

1. **Red** — Write failing unit tests in `#[cfg(test)] mod tests`
   - Use descriptive names: `test_should_<expected_behavior>_when_<condition>`
   - Cover happy path, error cases, and edge cases
   - Confirm the tests fail (implementation does not exist yet)
2. **Green** — Write the minimum production code to make the tests pass
   - Follow the interface design from the spec exactly
   - Handle all error cases properly — no `unwrap()` or `expect()` in production code
   - Add appropriate logging with `tracing` macros
3. **Refactor** — Clean up while keeping tests green
   - Add doc comments (`///`) for all public items with at least one example
   - Remove duplication, improve naming, simplify logic

Repeat this cycle for each sub-component before moving to the next.

### TDD Workflow — Tests First (Small Scope)

1. **Write all tests first** — Create unit tests in `#[cfg(test)] mod tests` for every public function and type in this phase
   - Use descriptive names: `test_should_<expected_behavior>_when_<condition>`
   - Cover happy path, error cases, and edge cases
   - Confirm the tests fail
2. **Implement** all production code to make tests pass
   - Follow the interface design from the spec exactly
   - Handle all error cases properly — no `unwrap()` or `expect()` in production code
   - Add appropriate logging with `tracing` macros
3. **Refactor** — Add doc comments, clean up code

### Key TDD Rules

- **Never write production code without a failing test that demands it**
- If you discover missing test coverage during implementation, write the test first, confirm it fails, then fix
- Tests drive the design — they are not an afterthought

## After Implementation

Run the following checks and fix any issues:
{% for check in checks %}
- `{{ check }}`
{% endfor %}

If any check fails:
1. Read the error output carefully
2. Fix the issue
3. Re-run the checks
4. Repeat until all checks pass

## Commit

Once all checks pass, commit with an appropriate conventional commit message:

```bash
{% if is_first %}
git add -A
{% endif %}
git commit -am "feat({{ feature_slug }}): {{ phase_name }}"
```

## Guidelines

- Implement ONLY what is described in this phase — do not jump ahead
- Each function should be focused and under 150 lines
- Use the project's existing patterns and conventions
- Prefer borrowing over cloning, iterators over explicit loops
- Add inline comments only for non-obvious logic
- Import order: std → external deps → local modules
