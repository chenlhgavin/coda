You are {% if force %}reinitializing{% else %}initializing{% endif %} a repository for use with CODA (Claude Orchestrated Development Agent).

## Repository

- **Root**: `{{ project_root }}`
{% if force %}- **Mode**: Reinitialize (update config and regenerate docs, preserve user settings){% endif %}

## Analysis Results

{{ analysis_result }}

## Task

Perform the following steps in order:
{% if force %}
### 1. Update `.coda/config.yml`

Read the existing config at `{{ project_root }}/.coda/config.yml`. **Preserve all user-customized settings** (such as `agent.max_budget_usd`, `agent.model`, `review.codex_reasoning_effort`, `git.branch_prefix`, etc.). Update the `checks` list to match the current tech stack detected in the analysis above. Set `review.engine` to `codex` (the current default). If any new config fields are missing from the existing file, add them with sensible defaults. **Important**: `review.codex_model` must be an OpenAI-compatible model (e.g., `gpt-5.3-codex`). If it is currently set to a Claude model (e.g., `claude-opus-4-6`), correct it to `gpt-5.3-codex`.

### 2. Regenerate `.coda.md`

Delete the existing `{{ project_root }}/.coda.md` and generate a fresh **developer-facing architecture reference**. This file is primarily consumed by AI agents and developers who need to understand the codebase quickly. Structure it as follows:

1. **Project Overview** — One paragraph: what the project does, the problem it solves, and its core value proposition
2. **Architecture Overview** — ASCII box diagram showing module/crate/package relationships and layer boundaries. Below the diagram, briefly describe each module's responsibility and how they depend on each other
3. **Interface Design** — List the key traits, interfaces, or abstract types that define module boundaries. For each, state: name, module path, what it abstracts, and why it exists. Include important public API signatures where they clarify contracts
4. **Data Flow** — Describe the primary data processing pipelines (e.g., request handling, feature lifecycle, message processing). Use ASCII flow diagrams where helpful. For each flow, list the stages and what data transformations occur at each stage
5. **Core Data Structures** — Document the key types, enums, and structs that form the domain model. Describe their relationships, state machines (if any), and serialization conventions
6. **Module Guide** — Table mapping directory paths to their purposes
7. **Tech Stack & Dependencies** — Languages, frameworks, key dependencies with their roles
8. **Development Workflow** — Build, test, format, lint commands
9. **Key Patterns & Conventions** — Architectural patterns (e.g., actor model, pipeline), error handling strategy, concurrency model, configuration approach, and any project-specific conventions

Start with: `# CODA Repository Overview` and `> Auto-generated by CODA. Keep in sync with the codebase.`

Base the content on the analysis results above. Keep under 300 lines.

### 3. Update `.gitignore`

Append the following to `{{ project_root }}/.gitignore` (create the file if it doesn't exist). Only add lines that are not already present:

```
# CODA worktrees
.trees/
```

### 4. Generate or Update `CLAUDE.md`

This file provides coding standards and development guidelines for AI agents and developers working on this project. The content must be tailored to the **detected tech stack and project characteristics** from the analysis results.

{% raw %}**If `CLAUDE.md` already exists:**{% endraw %}

1. Read the existing content carefully
2. Preserve all user-customized rules and project-specific guidelines
3. Ensure the following sections exist (add missing ones, do not duplicate existing ones):
   - **Core Principles** — SOLID/DRY, no incomplete code (no TODO/FIXME), thorough analysis before coding, remove dead code
   - **Design Principles** — Type safety (make illegal states unrepresentable), error handling strategy (specific to detected tech stack), API design conventions, prefer composition over inheritance
   - **Code Quality** — Linting rules, function size limits, import ordering, dead code policy
   - **Security** — Input validation, sensitive data handling, secrets management, TLS/crypto choices (tailored to tech stack)
   - **Testing (TDD)** — Test-first development workflow: write failing test → implement → refactor. Test naming conventions, unit/integration test organization, mocking strategy, coverage goals focused on critical paths and edge cases
   - **Code Style** — Naming conventions, formatting tools, import order, trailing commas (tailored to detected language)
   - **Toolchain & Build** — Build commands, lint commands, test commands, CI checks (based on detected tech stack)
4. Ensure the file ends with the CODA reference section (add if missing):

```markdown

## CODA Repository Documentation

See [.coda.md](.coda.md) for a comprehensive overview of this repository's structure, tech stack, and conventions. This file is auto-generated by CODA and kept up to date.
```

{% raw %}**If `CLAUDE.md` does not exist:**{% endraw %}

Generate a comprehensive `CLAUDE.md` with all sections listed above, tailored to the detected tech stack. For example:
- **Rust projects**: Include Rust-specific guidance (edition, `thiserror`/`anyhow`, `tokio` async patterns, `serde` conventions, `clippy` lints, `cargo fmt`/`cargo test` commands)
- **Node/TypeScript projects**: Include TS-specific guidance (strict mode, ESLint/Prettier, Jest/Vitest, import conventions)
- **Python projects**: Include Python-specific guidance (type hints, ruff/mypy, pytest, virtual environments)
- **Go projects**: Include Go-specific guidance (error wrapping, `golangci-lint`, table-driven tests, module conventions)

The file must end with the CODA reference section shown above.
{% else %}
### 1. Create `.coda/` directory

```bash
mkdir -p "{{ project_root }}/.coda"
```

### 2. Create `.trees/` directory

```bash
mkdir -p "{{ project_root }}/.trees"
```

### 3. Generate `.coda/config.yml`

Create the file `{{ project_root }}/.coda/config.yml`. Based on the detected tech stack in the analysis results above, determine the appropriate build/lint/format checks for this project and fill them in.

```yaml
# CODA Project Configuration
version: 1

agent:
  model: "claude-opus-4-6"
  permission_mode: "auto"
  max_retries: 3

git:
  auto_commit: true
  squash_before_push: true
  branch_prefix: "feature"
  commit_prefix: "feat"

review:
  enabled: true
  engine: codex
  codex_model: "gpt-5.3-codex"
  codex_reasoning_effort: "high"
  checks:
    # Determine appropriate checks from the detected tech stack.
    # Examples:
    #   Rust: cargo build, cargo +nightly fmt -- --check, cargo clippy -- -D warnings
    #   Node: npm run build, npm run lint, npm test
    #   Python: ruff check, mypy, pytest
    - "<fill based on tech stack>"
  max_review_rounds: 5
```

### 4. Update `.gitignore`

Append the following to `{{ project_root }}/.gitignore` (create the file if it doesn't exist). Only add lines that are not already present:

```
# CODA worktrees
.trees/
```

### 5. Generate `.coda.md`

Generate a **developer-facing architecture reference** at `{{ project_root }}/.coda.md`. This file is primarily consumed by AI agents and developers who need to understand the codebase quickly. Structure it as follows:

1. **Project Overview** — One paragraph: what the project does, the problem it solves, and its core value proposition
2. **Architecture Overview** — ASCII box diagram showing module/crate/package relationships and layer boundaries. Below the diagram, briefly describe each module's responsibility and how they depend on each other
3. **Interface Design** — List the key traits, interfaces, or abstract types that define module boundaries. For each, state: name, module path, what it abstracts, and why it exists. Include important public API signatures where they clarify contracts
4. **Data Flow** — Describe the primary data processing pipelines (e.g., request handling, feature lifecycle, message processing). Use ASCII flow diagrams where helpful. For each flow, list the stages and what data transformations occur at each stage
5. **Core Data Structures** — Document the key types, enums, and structs that form the domain model. Describe their relationships, state machines (if any), and serialization conventions
6. **Module Guide** — Table mapping directory paths to their purposes
7. **Tech Stack & Dependencies** — Languages, frameworks, key dependencies with their roles
8. **Development Workflow** — Build, test, format, lint commands
9. **Key Patterns & Conventions** — Architectural patterns (e.g., actor model, pipeline), error handling strategy, concurrency model, configuration approach, and any project-specific conventions

Start with: `# CODA Repository Overview` and `> Auto-generated by CODA. Keep in sync with the codebase.`

Base the content on the analysis results above. Keep under 300 lines.

### 6. Generate or Update `CLAUDE.md`

This file provides coding standards and development guidelines for AI agents and developers working on this project. The content must be tailored to the **detected tech stack and project characteristics** from the analysis results.

{% raw %}**If `CLAUDE.md` already exists:**{% endraw %}

1. Read the existing content carefully
2. Preserve all user-customized rules and project-specific guidelines
3. Ensure the following sections exist (add missing ones, do not duplicate existing ones):
   - **Core Principles** — SOLID/DRY, no incomplete code (no TODO/FIXME), thorough analysis before coding, remove dead code
   - **Design Principles** — Type safety (make illegal states unrepresentable), error handling strategy (specific to detected tech stack), API design conventions, prefer composition over inheritance
   - **Code Quality** — Linting rules, function size limits, import ordering, dead code policy
   - **Security** — Input validation, sensitive data handling, secrets management, TLS/crypto choices (tailored to tech stack)
   - **Testing (TDD)** — Test-first development workflow: write failing test → implement → refactor. Test naming conventions, unit/integration test organization, mocking strategy, coverage goals focused on critical paths and edge cases
   - **Code Style** — Naming conventions, formatting tools, import order, trailing commas (tailored to detected language)
   - **Toolchain & Build** — Build commands, lint commands, test commands, CI checks (based on detected tech stack)
4. Ensure the file ends with the CODA reference section (add if missing):

```markdown

## CODA Repository Documentation

See [.coda.md](.coda.md) for a comprehensive overview of this repository's structure, tech stack, and conventions. This file is auto-generated by CODA and kept up to date.
```

{% raw %}**If `CLAUDE.md` does not exist:**{% endraw %}

Generate a comprehensive `CLAUDE.md` with all sections listed above, tailored to the detected tech stack. For example:
- **Rust projects**: Include Rust-specific guidance (edition, `thiserror`/`anyhow`, `tokio` async patterns, `serde` conventions, `clippy` lints, `cargo fmt`/`cargo test` commands)
- **Node/TypeScript projects**: Include TS-specific guidance (strict mode, ESLint/Prettier, Jest/Vitest, import conventions)
- **Python projects**: Include Python-specific guidance (type hints, ruff/mypy, pytest, virtual environments)
- **Go projects**: Include Go-specific guidance (error wrapping, `golangci-lint`, table-driven tests, module conventions)

The file must end with the CODA reference section shown above.
{% endif %}

## Verification

After completing all steps, verify:
{% if force %}- [ ] `.coda/config.yml` is valid YAML with user settings preserved and checks updated
- [ ] `.coda.md` exists, is well-formatted, and includes Architecture Overview, Interface Design, and Data Flow sections
- [ ] `.gitignore` contains `.trees/`
- [ ] `CLAUDE.md` contains coding standards with Core Principles, Design Principles, Testing (TDD), Security, and Code Style sections
- [ ] `CLAUDE.md` ends with the CODA reference section
{% else %}- [ ] `.coda/` directory exists
- [ ] `.trees/` directory exists
- [ ] `.coda/config.yml` is valid YAML with appropriate checks
- [ ] `.gitignore` contains `.trees/`
- [ ] `.coda.md` exists, is well-formatted, and includes Architecture Overview, Interface Design, and Data Flow sections
- [ ] `CLAUDE.md` contains coding standards with Core Principles, Design Principles, Testing (TDD), Security, and Code Style sections
- [ ] `CLAUDE.md` ends with the CODA reference section
{% endif %}
Report the result of each verification step.
